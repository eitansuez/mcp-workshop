{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#preface","title":"Preface","text":"<p>In this workshop you will learn to build MCP servers and secure them with OAuth2.</p> <p>An important focus is building and deploying production-ready MCP services, ones that can be maintained, upgraded, consumed by multiple agents, and secured with authentication and authorization policies.</p> <p>The activities in this workshop were inspired by the work of Christian Posta and Lin Sun.</p> <p>One influence is Christian\u2019s four-part series \u201cUnderstanding MCP Authorization, Step by Step\u201d (GitHub Repository):</p> <ul> <li>Part 1: An MCP server</li> <li>Part 2: Hand-rolled OAuth</li> <li>Part 3: Keycloak</li> <li>Part 4: DCR</li> </ul> <p>Another is Christian Posta and Lin Sun\u2019s upcoming ebook AI Agents in Kubernetes.</p>"},{"location":"#the-workshop","title":"The workshop","text":"<p>In this workshop, you will:</p> <ol> <li>Build an MCP server &amp; test it with MCP inspector</li> <li>Provision Keycloak and configure it as the Identity Provider (IdP).</li> <li>Configure the MCP server with OAuth2 and demonstrate authentication flow.</li> <li>Introduce agentgateway as a passthrough proxy.</li> <li>Shift the authentication &amp; authorization configuration from the MCP server to the gateway</li> </ol> <p>We then shift focus to deploying the solution on Kubernetes.</p> <p>In the second part of this workshop, you will:</p> <ol> <li>Deploy MCP servers to Kubernetes.</li> <li>Build an agent (with kagent) that utilizes the tools exposed by the MCP server.</li> <li>See the tool server work in an end-to-end scenario with an agent.</li> </ol> <p>Note</p> <p>The second part of this workshop is not yet developed.</p>"},{"location":"mcp-server/","title":"A simple MCP server","text":"<p>Begin by creating a simple MCP service with a single, simple \u201cecho\u201d tool.</p>"},{"location":"mcp-server/#steps","title":"Steps","text":"<p>In a terminal, create a project directory and navigate to it:</p> <pre><code>mkdir echo-mcp-server &amp;&amp; cd echo-mcp-server\n</code></pre> <p>Initialize a python project:</p> <pre><code>uv init\n</code></pre> <p>We will use the fastmcp framework, so add the dependency:</p> <pre><code>uv add fastmcp\n</code></pre> <p>Review the following simple application that exposes a single \u201cecho\u201d tool:</p> main.py<pre><code>from typing import Annotated\nfrom fastmcp import FastMCP\nfrom pydantic import Field\n\nmcp = FastMCP(\"MCP Echo Server\")\n\n@mcp.tool\ndef echo(\n        message: Annotated[str, \"Message to echo\"],\n        repeat_count: Annotated[int, Field(description=\"Number of times to repeat the message\", ge=1, le=10)] = 3\n    ) -&gt; str:\n        \"\"\"Echo a message a specified number of times.\"\"\"\n        return message * repeat_count\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"http\", host=\"127.0.0.1\", port=8000)\n</code></pre> <p>Note</p> <ul> <li>The function produces a string that repeats the given message a given number of times.</li> <li>The MCP service is launched using the <code>http</code> transport on port 8000</li> </ul> <p>Copy the above <code>main.py</code> script to your project, replacing the stub <code>main.py</code> previously produced by <code>uv init</code>:</p> <pre><code>cp ../artifacts/main.py .\n</code></pre>"},{"location":"mcp-server/#test-it","title":"Test it","text":"<p>Launch the application:</p> <pre><code>uv run main.py\n</code></pre> <p>You should see the FastMCP banner come up.</p> <p>In a separate terminal, launch the MCP Inspector:</p> <pre><code>npx @modelcontextprotocol/inspector\n</code></pre> <p>In the Inspector\u2019s browser page, on the left hand side, specify:</p> <ol> <li>Transport Type:  <code>Streamable HTTP</code></li> <li>URL: <code>http://localhost:8000/mcp</code></li> </ol> <p>Click Connect.</p> <p>The inspector will switch to the Connected state.</p> <ul> <li>Select the <code>tools</code> tab from the header.</li> <li>Click List Tools - the <code>echo</code> tool will display.</li> <li>Select the <code>echo</code> tool.</li> <li>Enter a message.</li> <li>Click Run tool.</li> </ul> <p>Validate the results. Disconnect the inspector once you are satisfied that the tool is functioning properly and terminate the running MCP server (press Ctrl+C in the terminal).</p>"},{"location":"mcp-server/#summary","title":"Summary","text":"<p>We now have a basic MCP server. In the next step, we turn our attention to MCP authorization.</p>"},{"location":"oauth/","title":"MCP authorization","text":"<p>We wish to control access to (or otherwise protect) our MCP server.</p> <p>OAuth2 is an established authorization framework designed for this purpose. The main actors in OAuth2 flows are the authorization server, the resource server, the client, and the resource owner (a user).</p> <p>In the context of this workshop, the MCP server you just built becomes the resource server, whose responsibility it becomes to validate access tokens presented by clients requesting access to resources. When you tested your MCP server in the last section, the MCP inspector played the part of the client.</p> <p>In this section, you will provision and familiarize yourself with Keycloak, an open-source project for identity and access management, that will act as your authorization server and identity provider (IdP).</p>"},{"location":"oauth/#provision-keycloak","title":"Provision Keycloak","text":"<p>In the spirit of doing this simplest thing that will work, run Keycloak with Docker, as follows:</p> <pre><code>docker run -d --name keycloak -p 8080:8080 \\\n  -e KC_BOOTSTRAP_ADMIN_USERNAME=admin \\\n  -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin \\\n  -v ./artifacts/keycloak-seed:/opt/keycloak/data/import \\\n  quay.io/keycloak/keycloak:latest start-dev --import-realm\n</code></pre> <p>Explanation:</p> <ul> <li>We name the container <code>keycloak</code>, for easy reference.</li> <li>Set the admin username and password to <code>admin/admin</code>.</li> <li><code>start-dev</code> starts Keycloak in development mode (suitable for sandbox environments and learning).</li> <li>The folder <code>keycloak-seed</code> is mounted to the Keycloak data import conventional location for importing configuration.</li> <li>The <code>--import-realm</code> flag ensures that a configuration file is imported on start.</li> </ul> <p>Keycloak has the concept of a realm \u2013 a logical grouping of users, applications, and identity-related configurations.</p> <p>The configuration you just imported consists of:</p> <ul> <li>A realm named <code>my-realm</code>.</li> <li>A pre-configured user: <code>eitan/test</code>.</li> <li>A client named <code>mcp-client</code>, pre-configured with the audience named <code>echo-mcp-server</code>.</li> </ul> <p>Optional scopes can be additionally configured to support different levels of authorization, though none are defined by default.</p>"},{"location":"oauth/#review-the-keycloak-configuration","title":"Review the Keycloak configuration","text":"<p>With Keycloak up and running, visit its web user interface at http://localhost:8080/.</p> <ul> <li>Log in as administrator using the above cited \u201cadmin\u201d credentials.</li> <li>Click \u201cManage realms\u201d and select the realm named <code>my-realm</code> to render it the \u201ccurrent\u201d realm.</li> <li>Select \u201cUsers\u201d and verify that a user named \u201ceitan\u201d is predefined.</li> <li>Select clients and note that the client <code>mcp-client</code> is predefined.</li> <li>Select the client <code>mcp-client</code> and the tab <code>Client scopes</code>, and the scope named <code>mcp-client-dedicated</code> and note the presence of the audience mapper <code>echo-mcp-server</code></li> </ul>"},{"location":"oauth/#summary","title":"Summary","text":"<p>Great!  That should be all we need to implement the authorization server.</p> <p>Make note of the following pieces of information, which you will need in the next step, as you configure your resource server to validate tokens presented by clients:</p> <ul> <li>audience: <code>echo-mcp-server</code></li> <li>issuer: <code>http://localhost:8080/realms/my-realm</code></li> <li>jwks URI: <code>http://localhost:8080/realms/my-realm/protocol/openid-connect/certs</code></li> </ul> <p>The audience represents the intended audience for the token, and to disambiguate these tokens from ones relevant in the context of other applications and resources.</p> <p>The token issuer is the URL of the realm <code>my-realm</code> in Keycloak.</p> <p>The jwks URI is where the resource server goes to fetch a copy of the public key needed to verify the validity of token signatures.</p>"},{"location":"proxy-mcp/","title":"Proxy the MCP Server","text":"<p>In the previous section you configured an authenticated MCP server by using FastMCP\u2019s built-in authentication support.</p> <p>In a production setting, we are much better off separating the concern of implementing the MCP server\u2019s functionality from that of configuring authorization (or any other cross-cutting concern beyond security, such as observability, for example).</p> <p>In this exercise, security policy configuration and enforcement is moved out of the application and into a proxy.</p>"},{"location":"proxy-mcp/#agentgateway","title":"agentgateway","text":"<p>agentgateway is a modern proxy that supports modern AI protocols including MCP and A2A.</p> <p>The documentation provides an example for configuring and running the gateway to route requests to an MCP backend.</p> <p>Let\u2019s give it a try to understand how this works.</p>"},{"location":"proxy-mcp/#proxy-the-mcp-server_1","title":"Proxy the MCP server","text":"<p>Run the basic MCP server:</p> <pre><code>uv run main.py\n</code></pre> <p>Review the following agentgateway configuration file:</p> ag-config.yaml<pre><code>binds:\n- port: 9000\n  listeners:\n  - routes:\n    - policies:\n        cors:\n          allowOrigins:\n          - \"*\"\n          allowHeaders:\n          - \"*\"\n      backends:\n      - mcp:\n          targets:\n          - name: mcp\n            mcp:\n              host: http://localhost:8000/mcp\n</code></pre> <p>Above, we configure agentgateway to listen on port 9000, and to route all requests (with a liberal CORS policy) to our MCP backend listening on port 8000.</p> <p>Copy the above <code>ag-config.yaml</code> script to your project:</p> <pre><code>cp ../artifacts/ag-config.yaml .\n</code></pre>"},{"location":"proxy-mcp/#test-it","title":"Test it","text":"<p>Start the agentgateway:</p> <pre><code>agentgateway -f ag-config.yaml\n</code></pre> <p>Launch the MCP inspector:</p> <pre><code>npx @modelcontextprotocol/inspector\n</code></pre> <p>Point the URL field to the agentgateway proxy running on port 9000:  http://localhost:9000/mcp</p> <p>Click Connect and confirm that everything works, as if we were communicating directly with the MCP server.</p> <p>Inspect the logs of the agentgateway console to see evidence that requests are indeed routed via the proxy.</p> <p>Terminate the agentgateway (press <code>Ctrl+C</code>).</p>"},{"location":"proxy-mcp/#configure-authentication","title":"Configure authentication","text":"<p>The project documentation provides an example for configuring MCP authentication directly on the proxy.</p> <p>Review the updated agentgateway configuration file:</p> ag-oauth-config.yaml<pre><code>binds:\n- port: 9000\n  listeners:\n  - routes:\n    - policies:\n        cors:\n          allowOrigins:\n          - \"*\"\n          allowHeaders:\n          - \"*\"\n        mcpAuthentication:\n          issuer: http://localhost:8080/realms/my-realm\n          jwksUrl: http://localhost:8080/realms/my-realm/protocol/openid-connect/certs\n          audience: echo-mcp-server\n          resourceMetadata:\n            resource: http://localhost:9000/mcp\n            scopesSupported:\n            - openid\n            bearerMethodsSupported:\n            - header\n      backends:\n      - mcp:\n          targets:\n          - name: mcp\n            mcp:\n              host: http://localhost:8000/mcp\n</code></pre> <p>Above, note that the configuration utilizes the same <code>issuer</code>, <code>jwksUrl</code>, and <code>audience</code> field values for the authorization server.</p> <p>Copy the above <code>ag-oauth-config.yaml</code> script to your project:</p> <pre><code>cp ../artifacts/ag-oauth-config.yaml .\n</code></pre>"},{"location":"proxy-mcp/#test-it_1","title":"Test it","text":"<p>If it\u2019s not already running, start the basic, unprotected MCP server:</p> <pre><code>uv run main.py\n</code></pre> <p>Start the agentgateway:</p> <pre><code>agentgateway -f ag-oauth-config.yaml\n</code></pre> <p>Finally, launch the MCP Inspector.</p> <pre><code>npx @modelcontextprotocol/inspector\n</code></pre> <p>This MCP server should be protected.</p> <p>Start by walking through the Guided OAuth flow:</p> <ul> <li>Click Open Auth Settings in the center of the page.</li> <li>Click Guided OAuth Flow.</li> <li>Like before, go through all steps from Metadata Discovery through to Token request.</li> <li>When instructed to follow the authorization URL, log in with the user credentials <code>eitan/test</code>.</li> <li>Copy and pate the authorization code into the corresponding field.</li> </ul> <p>When the authentication completes, we have been issued a token.</p> <p>Proceed to click Connect on the left hand panel, and to confirm that interaction with the MCP server continues to function as before: Tools -&gt; List Tools -&gt; Echo -&gt; Run Tool.</p>"},{"location":"proxy-mcp/#summary","title":"Summary","text":"<p>Congratulations!  You now have a flexible configuration: an MCP server fronted by an intelligent proxy where MCP authentication is configured.</p>"},{"location":"resource-server/","title":"Configure the resource server","text":"<p>The gist of the OAuth flow is that an authorization server issues tokens that give clients access to protected resources for a limited time.</p> <p>The resource server has the responsibility of enforcing the authorization policy, by:</p> <ul> <li>Checking that requests are accompanied by a JWT token.</li> <li>Verifying the token\u2019s authenticity (by checking the signature of the token).</li> <li>Verifying the token\u2019s expiration timestamp.</li> <li>Verifying the token\u2019s audience scope matches the intended audience (<code>echo-mcp-server</code>).</li> </ul> <p>In this section we begin implementing this enforcement by coding it directly in the application.</p>"},{"location":"resource-server/#instructions","title":"Instructions","text":"<p>Review the following updated application:</p> main-with-auth.py<pre><code>from typing import Annotated\n\nfrom fastmcp import FastMCP\nfrom fastmcp.server.auth import RemoteAuthProvider\nfrom fastmcp.server.auth.providers.jwt import JWTVerifier\nfrom pydantic import AnyHttpUrl, Field\n\nauth_provider = RemoteAuthProvider(\n    token_verifier=JWTVerifier(\n        jwks_uri=\"http://localhost:8080/realms/my-realm/protocol/openid-connect/certs\",\n        issuer=\"http://localhost:8080/realms/my-realm\",\n        audience=\"echo-mcp-server\"\n    ),\n    authorization_servers=[AnyHttpUrl(\"http://localhost:8080/realms/my-realm\")],\n    base_url=\"http://localhost:8000\"\n)\n\nmcp = FastMCP(\"MCP Echo Server\", auth=auth_provider)\n\n@mcp.tool\ndef echo(\n        message: Annotated[str, \"Message to echo\"],\n        repeat_count: Annotated[int, Field(description=\"Number of times to repeat the message\", ge=1, le=10)] = 3\n    ) -&gt; str:\n        \"\"\"Echo a message a specified number of times.\"\"\"\n        return message * repeat_count\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"http\", host=\"127.0.0.1\", port=8000)\n</code></pre> <p>The main difference from <code>main.py</code> is the construction of the FastMCP object with the auth provider <code>auth_provider</code>. Note how the <code>jwks_uri</code>, <code>issuer</code>, and <code>audience</code> match those of the authorization server provisioned in the previous section.</p> <p>Copy the above <code>main-with-auth.py</code> script to your project:</p> <pre><code>cp ../artifacts/main-with-auth.py .\n</code></pre>"},{"location":"resource-server/#test-it","title":"Test it","text":"<p>Start the MCP server:</p> <pre><code>uv run main-with-auth.py\n</code></pre> <p>In a separate terminal, attempt to make an HTTP POST request to the <code>/mcp</code> endpoint:</p> <pre><code>curl -s -v -X POST http://localhost:8000/mcp\n</code></pre> <p>Here are the salient parts of the captured response:</p> <pre><code>* Host localhost:8000 was resolved.\n* ...\n* Established connection to localhost (127.0.0.1 port 8000) from 127.0.0.1 port 65521\n* using HTTP/1.x\n&gt; POST /mcp HTTP/1.1\n&gt; Host: localhost:8000\n&gt; User-Agent: curl/8.16.0\n&gt; Accept: ..\n&gt;\n* Request completely sent off\n&lt; HTTP/1.1 401 Unauthorized\n&lt; date: Wed, 15 Oct 2025 18:09:13 GMT\n&lt; server: uvicorn\n&lt; content-type: application/json\n&lt; content-length: 74\n&lt; www-authenticate: Bearer error=\"invalid_token\", \\\n    error_description=\"Authentication required\", \\\n    resource_metadata=\"http://localhost:8000/.well-known/oauth-protected-resource\"\n&lt;\n* Connection #0 to host localhost:8000 left intact\n{\"error\": \"invalid_token\", \"error_description\": \"Authentication required\"}\n</code></pre> <p>Above, note that we were not granted access to the resource, due to the absence of a valid access token in the request.</p> <p>We get a 401 \u201cUnauthorized\u201d response. The interesting part is the presence of the response header <code>www-authenticate</code>, whose value include the <code>resource_metadata</code> attribute which tells the client where to find the authorization server.</p> <p>If we query that URL <sup>*</sup>:</p> <pre><code>curl -s http://localhost:8000/.well-known/oauth-protected-resource/mcp | jq\n</code></pre> <p><sup>*</sup> Above</p> <p>FastMCP appends the suffix <code>/mcp</code> to the oauth protected resource.</p> <p>We are indeed told where to find the authorization server:</p> <pre><code>{\n  \"resource\": \"http://localhost:8000/mcp\",\n  \"authorization_servers\": [\n    \"http://localhost:8080/realms/my-realm\"\n  ],\n  \"scopes_supported\": [],\n  \"bearer_methods_supported\": [\n    \"header\"\n  ]\n}\n</code></pre> <p>Above</p> <p>The field <code>scopes_supported</code> is empty because we didn\u2019t configure a list of valid scopes for the application.</p>"},{"location":"resource-server/#test-the-full-oauth-flow","title":"Test the full OAuth flow","text":"<p>Launch the MCP inspector:</p> <pre><code>npx @modelcontextprotocol/inspector\n</code></pre> <p>In the form panel on the left:</p> <ul> <li>Expand Authentication.</li> <li>Set the Client ID to <code>mcp-client</code>.</li> <li>Click Open Auth Settings (in the middle of the page).</li> </ul> <p>The Authentication Settings page in the inspector provides a guided OAuth flow.</p> <ol> <li>Metadata Discovery:  click the Continue button.   Expand the OAuth Metadata Sources.   The inspector fetched the discovery endpoint and used it to introspect Keycloak\u2019s metadata to discover the endpoints for registration, authorization, and the token endpoint.</li> <li>Client registration:  since we\u2019re using a registered client <code>mcp-client</code>, no registration takes place.  Click Continue</li> <li>Preparing Authorization: This is where the client constructs the authorization URL.    Follow the URL, and log in to Keycloak using the realm user <code>eitan</code> (password <code>test</code>).:w    An authorization code is presented.  Copy it and paste it into the Authorization Code field.    Click Continue</li> <li>Token Request: Click Continue.  The inspector will call the token endpoint with the supplied authorization code.</li> <li>Authentication Complete: Expand Access Tokens to revel the access token obtained from the token endpoint.    Feel free to use sites such as jwt.io to decode the access token and confirm that the audience scope is present in the token.</li> </ol> <p>The full flow functions:  Click Connect and confirm that you can still list tools and call the <code>echo</code> tool as before.</p> <p>Disconnect from the MCP Server and terminate the application.</p>"},{"location":"resource-server/#summary","title":"Summary","text":"<p>Congrats!  Basic OAuth authorization is functioning.</p> <p>But the solution is not ideal, in that the authorization enforcement concern is coupled to the application logic.</p> <p>A better solution would be to separate those two responsibilities, which can be implemented with the aid of a proxy \u2013 the subject of the next section.</p>"}]}