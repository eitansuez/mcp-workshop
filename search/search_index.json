{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#preface","title":"Preface","text":"<p>In this workshop you will learn to build MCP servers and secure them with OAuth2.</p> <p>An important focus is building and deploying production-ready MCP services, ones that can be maintained, upgraded, consumed by multiple agents, and secured with authentication and authorization policies.</p> <p>The activities in this workshop were inspired by the work of Christian Posta and Lin Sun.</p> <p>One influence is Christian\u2019s four-part series \u201cUnderstanding MCP Authorization, Step by Step\u201d (GitHub Repository):</p> <ul> <li>Part 1: An MCP server</li> <li>Part 2: Hand-rolled OAuth</li> <li>Part 3: Keycloak</li> <li>Part 4: DCR</li> </ul> <p>Another is Christian Posta and Lin Sun\u2019s upcoming ebook AI Agents in Kubernetes.</p>"},{"location":"#the-workshop","title":"The workshop","text":"<p>In this workshop, you will:</p> <ol> <li>Build an MCP server &amp; test it with MCP inspector</li> <li>Provision Keycloak and configure it as the Identity Provider (IdP).</li> <li>Configure the MCP server with OAuth2 and demonstrate authentication flow.</li> <li>Introduce agentgateway as a proxy, and shift the authentication &amp; authorization enforcement from the MCP server to the gateway</li> <li>Configure the gateway to perform JWT authentication instead, and apply an MCP authorization policy.</li> </ol> <p>We then shift focus to deploying the solution on Kubernetes.</p> <p>In the final activity, you will learn to build and deploy an MCP server to Kubernetes.</p>"},{"location":"enterprise-sso/","title":"Enterprise Single sign-on (SSO)","text":"<p>In enterprises, employees log in to multiple workplace applications with a single set of credentials.</p> <p>Employees will already bear a JWT token in the requests they make.</p> <p>For our MCP server to work in that context, we can revise the gateway\u2019s configuration to verify the enterprise-issued JWT token.</p> <p>agentgateway supports JWT Authentication, which resembles our previous configuration, in that token verification still involves an issuer, an audience, and a jwks URL.</p> <p>Let us demonstrate how this works.</p>"},{"location":"enterprise-sso/#jwt-authentication","title":"JWT Authentication","text":"<p>Use the step CLI to generate a key pair:</p> <pre><code>step crypto jwk create pub-key priv-key\n</code></pre> <p>Press enter when prompted for a password to protect the key.</p> <p>Next, generate the JSON Web Key:</p> <pre><code>cat pub-key | step crypto jwk keyset add jwks-keyset\n</code></pre> <p>Generate and sign a JWT token, with a specified issuer and audience:</p> <pre><code>step crypto jwt sign --key priv-key \\\n  --iss \"acme@example.com\" --aud=\"mcp.example.com\" \\\n  --sub \"jsmith\" --exp $(date -v+10y +\"%s\") &gt; jsmith.token\n</code></pre> <p>Review the following agentgateway configuration, which requires a valid JWT token to access the MCP server:</p> ag-jwtauth-config.yaml<pre><code>binds:\n- port: 9000\n  listeners:\n  - routes:\n    - policies:\n        cors:\n          allowOrigins:\n          - \"*\"\n          allowHeaders:\n          - \"*\"\n        jwtAuth:\n          mode: strict\n          issuer: \"acme@example.com\"\n          audiences: [mcp.example.com]\n          jwks:\n            file: ./jwks-keyset\n      backends:\n      - mcp:\n          targets:\n          - name: mcp\n            mcp:\n              host: http://localhost:8000/mcp\n</code></pre> <p>Copy the above <code>ag-jwtauth-config.yaml</code> script to your project:</p> <pre><code>cp ../artifacts/ag-jwtauth-config.yaml .\n</code></pre>"},{"location":"enterprise-sso/#test-it","title":"Test it","text":"<p>Run the basic MCP server:</p> <pre><code>uv run main.py\n</code></pre> <p>Start the agentgateway:</p> <pre><code>./agentgateway -f ag-jwtauth-config.yaml\n</code></pre> <p>Launch the MCP inspector:</p> <pre><code>npx @modelcontextprotocol/inspector\n</code></pre> <p>Attempt to connect to the MCP server. The request will fail.</p> <p>A line in the <code>agentgateway</code> logs will confirm that the request was denied due to the absence of a bearer token:</p> <pre><code>2025-10-17T18:00:57.855104Z     info    request gateway=bind/9000 listener=listener0 \\\n  route_rule=route0/default route=route0 src.addr=[::1]:63358 http.method=POST \\\n  http.host=localhost http.path=/mcp http.version=HTTP/1.1 \\\n  http.status=403 protocol=http error=\"authentication failure: no bearer token found\" duration=0ms\n</code></pre> <p>Next, under Authentication -&gt; Custom Headers, click <code>+ Add</code>, set the header, as follows:</p> <ul> <li>Header Name: <code>Authorization</code></li> <li>Header Value: <code>Bearer &lt;paste the contents of the file jsmith.token&gt;</code></li> </ul> <p>And click Connect. The connection will succeed, and we can proceed to list tools and run the echo tool.</p> <p>Disconnect the MCP inspector.</p>"},{"location":"enterprise-sso/#mcp-authorization","title":"MCP Authorization","text":"<p>agentgateway supports configuring authorization policy for MCP requests and gives us access to MCP-specific metadata, such as the tool name being invoked. We also get information from the JWT token, such as claims.</p> <p>The following gateway configuration adds an MCP authorization policy which requires the user to have administrative privileges (role claim contains \u201cadmin\u201d) in order to access the <code>echo</code> tool:</p> ag-mcp-authorization.yaml<pre><code>binds:\n- port: 9000\n  listeners:\n  - routes:\n    - policies:\n        cors:\n          allowOrigins:\n          - \"*\"\n          allowHeaders:\n          - \"*\"\n        jwtAuth:\n          mode: strict\n          issuer: \"acme@example.com\"\n          audiences: [mcp.example.com]\n          jwks:\n            file: ./jwks-keyset\n        mcpAuthorization:\n          rules:\n          - 'mcp.tool.name == \"echo\" &amp;&amp; \"admin\" in jwt.roles'\n      backends:\n      - mcp:\n          targets:\n          - name: mcp\n            mcp:\n              host: http://localhost:8000/mcp\n</code></pre> <p>Copy the above <code>ag-mcp-authorization.yaml</code> script to your project:</p> <pre><code>cp ../artifacts/ag-mcp-authorization.yaml .\n</code></pre> <p>Restart the agentgateway with the authorization configuration:</p> <pre><code>./agentgateway -f ag-mcp-authorization.yaml\n</code></pre> <p>Attempt to connect again. The connection is permitted.</p> <p>However, attempt to List tools (you may need to clear tools first, to clear lingering results), the echo tool is no longer listed.</p> <p>Generate a second JWT, this time for an admin user:</p> <pre><code>echo '{ \"roles\": [\"admin\"] }' | \\\n  step crypto jwt sign --key priv-key \\\n    --iss \"acme@example.com\" --aud=\"mcp.example.com\" \\\n    --sub \"pointy-haired-boss\" --exp $(date -v+10y +\"%s\") &gt; boss.token\n</code></pre> <p>In the MCP inspector, replace the Authorization header with the admin user\u2019s JWT token.</p> <ul> <li>Try to connect again</li> <li>List tools</li> </ul> <p>The echo tool will be present this time since this user is allowed to call it.</p>"},{"location":"mcp-k8s/","title":"Targeting Kubernetes","text":"<p>Activities so far have run MCP servers on a local machine. This is useful when developing.</p> <p>In this final activity, you will learn about kmcp, (a part of the kagent project) a tool designed specifically to aid with the end-to-end process, from scaffolding a new project, to building a Docker image, to deploying the MCP server to Kubernetes.</p> <p>install the kmcp CLI</p> <pre><code>curl -fsSL https://raw.githubusercontent.com/kagent-dev/kmcp/refs/heads/main/scripts/get-kmcp.sh | bash\n</code></pre> <p>A Kubernetes cluster is running.</p> <p>Deploy the kmcp CRDs:</p> <pre><code>helm install kmcp-crds oci://ghcr.io/kagent-dev/kmcp/helm/kmcp-crds \\\n  --namespace kmcp-system \\\n  --create-namespace\n</code></pre> <p>Run <code>kmcp install</code> to deploy the Kubernetes controller:</p> <pre><code>kmcp install\n</code></pre>"},{"location":"mcp-k8s/#scaffolding","title":"Scaffolding","text":"<p>kmcp supports multiple target frameworks: go, python, java, and typescript.</p> <pre><code>kmcp init --help\n</code></pre> <p>Start a new python project:</p> <pre><code>kmcp init python my-mcp-server --description \"My first mcp server\" --non-interactive \\\n  &amp;&amp; cd my-mcp-server\n</code></pre> <p>Inspect the project directory structure:</p> <pre><code>tree .\n</code></pre> <p>An example <code>echo</code> tool is present by default. It\u2019s easy to add more tools by adding more <code>.py</code> files to the <code>tools/</code> subdirectory.</p>"},{"location":"mcp-k8s/#test-the-mcp-server","title":"Test the MCP Server","text":"<p>The kmcp CLI provides a convenient <code>run</code> command:</p> <pre><code>kmcp run\n</code></pre> <p>It launches the MCP server, and the MCP inspector, allowing us to test connecting to the server, listing tools, and running them.</p>"},{"location":"mcp-k8s/#build-and-package","title":"Build and Package","text":"<p>The kmcp <code>build</code> command simplifies building and packaging the MCP server:</p> <pre><code>kmcp build --help\n</code></pre> <p>Building the MCP server produces a Docker image:</p> <pre><code>kmcp build --tag my-mcp-server:latest\n</code></pre> <p>Next, we can publish the container image to a registry.</p> <p>Here let\u2019s simply upload the image to the cluster:</p> <pre><code>k3d image import my-mcp-server --cluster my-k8s-cluster\n</code></pre>"},{"location":"mcp-k8s/#deploy","title":"Deploy","text":"<p>Finally, deploy the MCP server to the cluster:</p> <pre><code>kmcp deploy --file kmcp.yaml --image my-mcp-server:latest\n</code></pre> <p>Deployment generates and applies an MCPServer resource to the cluster:</p> <pre><code>kubectl get mcpserver my-mcp-server -o yaml\n</code></pre> <p>The kmcp controller watches for MCPServer resources and creates (and applies) the deployment manifest for us:</p> <pre><code>kubectl get pod\n</code></pre> <p>The above deploy command also launches an MCP inspector allowing us to test the deployed MCP server.</p>"},{"location":"mcp-k8s/#summary","title":"Summary","text":"<p>Congratulations!  Your MCP server is now running on Kubernetes.</p> <p>The story does not end here.</p> <p>Agentgateway is supported in Kubernetes by the kgateway project, a control plane that can dynamically program agentgateway using cloud-native APIs such as the Kubernetes Gateway API and AI extensions.</p> <p>With kgateway, we can deploy an agentgateway proxy for our MCP server and configure it to route requests to the MCP server, with MCP authorization and other policies. See Christian Posta and Lin Sun\u2019s upcoming ebook AI Agents in Kubernetes for more information.</p>"},{"location":"mcp-server/","title":"A simple MCP server","text":"<p>Begin by creating a simple MCP service with a single, simple \u201cecho\u201d tool.</p>"},{"location":"mcp-server/#steps","title":"Steps","text":"<p>In a terminal, create a project directory and navigate to it:</p> <pre><code>mkdir echo-mcp-server &amp;&amp; cd echo-mcp-server\n</code></pre> <p>Initialize a python project:</p> <pre><code>uv init\n</code></pre> <p>We will use the fastmcp framework, so add the dependency:</p> <pre><code>uv add fastmcp\n</code></pre> <p>Review the following simple application that exposes a single \u201cecho\u201d tool:</p> main.py<pre><code>from typing import Annotated\nfrom fastmcp import FastMCP\nfrom pydantic import Field\n\nmcp = FastMCP(\"MCP Echo Server\")\n\n@mcp.tool\ndef echo(\n        message: Annotated[str, \"Message to echo\"],\n        repeat_count: Annotated[int, Field(description=\"Number of times to repeat the message\", ge=1, le=10)] = 3\n    ) -&gt; str:\n        \"\"\"Echo a message a specified number of times.\"\"\"\n        return message * repeat_count\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"http\", host=\"127.0.0.1\", port=8000)\n</code></pre> <p>Note</p> <ul> <li>The function produces a string that repeats the given message a given number of times.</li> <li>The MCP service is launched using the <code>http</code> transport on port 8000</li> </ul> <p>Copy the above <code>main.py</code> script to your project, replacing the stub <code>main.py</code> previously produced by <code>uv init</code>:</p> <pre><code>cp ../artifacts/main.py .\n</code></pre>"},{"location":"mcp-server/#test-it","title":"Test it","text":"<p>Launch the application:</p> <pre><code>uv run main.py\n</code></pre> <p>You should see the FastMCP banner come up.</p> <p>In a separate terminal, launch the MCP Inspector:</p> <pre><code>npx @modelcontextprotocol/inspector\n</code></pre> <p>In the Inspector\u2019s browser page, on the left hand side, specify:</p> <ol> <li>Transport Type:  <code>Streamable HTTP</code></li> <li>URL: <code>http://localhost:8000/mcp</code></li> </ol> <p>Click Connect.</p> <p>The inspector will switch to the Connected state.</p> <ul> <li>Select the <code>tools</code> tab from the header.</li> <li>Click List Tools - the <code>echo</code> tool will display.</li> <li>Select the <code>echo</code> tool.</li> <li>Enter a message.</li> <li>Click Run tool.</li> </ul> <p>Validate the results. Disconnect the inspector once you are satisfied that the tool is functioning properly and terminate the running MCP server (press Ctrl+C in the terminal).</p>"},{"location":"mcp-server/#summary","title":"Summary","text":"<p>We now have a basic MCP server. In the next step, we turn our attention to MCP authorization.</p>"},{"location":"oauth/","title":"MCP authorization","text":"<p>We wish to control access to (or otherwise protect) our MCP server.</p> <p>OAuth2 is an established authorization framework designed for this purpose. The main actors in OAuth2 flows are the authorization server, the resource server, the client, and the resource owner (a user).</p> <p>In the context of this workshop, the MCP server you just built becomes the resource server, whose responsibility it becomes to validate access tokens presented by clients requesting access to resources. When you tested your MCP server in the last section, the MCP inspector played the part of the client.</p> <p>In this section, you will provision and familiarize yourself with Keycloak, an open-source project for identity and access management, that will act as your authorization server and identity provider (IdP).</p>"},{"location":"oauth/#provision-keycloak","title":"Provision Keycloak","text":"<p>In the spirit of doing this simplest thing that will work, run Keycloak with Docker, as follows:</p> <pre><code>docker run -d --name keycloak -p 8080:8080 \\\n  -e KC_BOOTSTRAP_ADMIN_USERNAME=admin \\\n  -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin \\\n  -v ../artifacts/keycloak-seed:/opt/keycloak/data/import \\\n  quay.io/keycloak/keycloak:latest start-dev --import-realm\n</code></pre> <p>Explanation:</p> <ul> <li>We name the container <code>keycloak</code>, for easy reference.</li> <li>Set the admin username and password to <code>admin/admin</code>.</li> <li><code>start-dev</code> starts Keycloak in development mode (suitable for sandbox environments and learning).</li> <li>The folder <code>keycloak-seed</code> is mounted to the Keycloak data import conventional location for importing configuration.</li> <li>The <code>--import-realm</code> flag ensures that a configuration file is imported on start.</li> </ul> <p>Keycloak has the concept of a realm \u2013 a logical grouping of users, applications, and identity-related configurations.</p> <p>The configuration you just imported consists of:</p> <ul> <li>A realm named <code>my-realm</code>.</li> <li>A pre-configured user: <code>eitan/test</code>.</li> <li>A client named <code>mcp-client</code>.</li> <li>A client scope named <code>mcp:tools</code> that configures the token\u2019s audience to <code>echo-mcp-server</code>.</li> </ul> <p>Optional scopes can be additionally configured to support different levels of authorization, though none are defined by default.</p>"},{"location":"oauth/#review-the-keycloak-configuration","title":"Review the Keycloak configuration","text":"<p>With Keycloak up and running, visit its web user interface at http://localhost:8080/.</p> <ul> <li>Log in as administrator using the above cited \u201cadmin\u201d credentials.</li> <li>Click \u201cManage realms\u201d and select the realm named <code>my-realm</code> to render it the \u201ccurrent\u201d realm.</li> <li>Select \u201cUsers\u201d and verify that a user named \u201ceitan\u201d is predefined.</li> <li>Select \u201cClients\u201d and note that the client <code>mcp-client</code> is predefined.</li> <li>Select \u201cClient scopes\u201d, and the scope named <code>mcp:tools</code>, note under \u201cMappers\u201d the mapper named <code>echo-mcp-server</code> which configures the audience for the token.</li> </ul>"},{"location":"oauth/#summary","title":"Summary","text":"<p>Great!  That should be all we need to implement the authorization server.</p> <p>Make note of the following pieces of information, which you will need in the next step, as you configure your resource server to validate tokens presented by clients:</p> <ul> <li>audience: <code>echo-mcp-server</code></li> <li>issuer: <code>http://localhost:8080/realms/my-realm</code></li> <li>jwks URI: <code>http://localhost:8080/realms/my-realm/protocol/openid-connect/certs</code></li> </ul> <p>The audience represents the intended audience for the token, and to disambiguate these tokens from ones relevant in the context of other applications and resources.</p> <p>The token issuer is the URL of the realm <code>my-realm</code> in Keycloak.</p> <p>The jwks URI is where the resource server goes to fetch a copy of the public key needed to verify the validity of token signatures.</p>"},{"location":"proxy-mcp/","title":"Proxy the MCP Server","text":"<p>In the previous section you configured an authenticated MCP server by using FastMCP\u2019s built-in authentication support.</p> <p>In a production setting, we are much better off separating the concern of implementing the MCP server\u2019s functionality from that of configuring authorization (or any other cross-cutting concern beyond security, such as observability, for example).</p> <p>In this exercise, security policy configuration and enforcement is moved out of the application and into a proxy.</p>"},{"location":"proxy-mcp/#agentgateway","title":"agentgateway","text":"<p>agentgateway is a modern proxy that supports modern AI protocols including MCP and A2A.</p>"},{"location":"proxy-mcp/#install-agentgateway","title":"Install agentgateway","text":"<p>Install the <code>agentgateway</code> binary to your project directory:</p> <pre><code>USE_SUDO=false AGENTGATEWAY_INSTALL_DIR=. curl https://raw.githubusercontent.com/agentgateway/agentgateway/refs/heads/main/common/scripts/get-agentgateway | bash\n</code></pre>"},{"location":"proxy-mcp/#proxy-the-mcp-server_1","title":"Proxy the MCP server","text":"<p>The documentation provides an example for configuring and running the gateway to route requests to an MCP backend.</p> <p>Let\u2019s give it a try to understand how this works.</p> <p>Run the basic MCP server:</p> <pre><code>uv run main.py\n</code></pre> <p>Review the following agentgateway configuration file:</p> ag-config.yaml<pre><code>binds:\n- port: 9000\n  listeners:\n  - routes:\n    - policies:\n        cors:\n          allowOrigins:\n          - \"*\"\n          allowHeaders:\n          - \"*\"\n      backends:\n      - mcp:\n          targets:\n          - name: mcp\n            mcp:\n              host: http://localhost:8000/mcp\n</code></pre> <p>Above, we configure agentgateway to listen on port 9000, and to route all requests (with a liberal CORS policy) to our MCP backend listening on port 8000.</p> <p>Copy the above <code>ag-config.yaml</code> script to your project:</p> <pre><code>cp ../artifacts/ag-config.yaml .\n</code></pre>"},{"location":"proxy-mcp/#test-it","title":"Test it","text":"<p>Start the agentgateway:</p> <pre><code>./agentgateway -f ag-config.yaml\n</code></pre> <p>Launch the MCP inspector:</p> <pre><code>npx @modelcontextprotocol/inspector\n</code></pre> <p>Point the URL field to the agentgateway proxy running on port 9000:  <code>http://localhost:9000/mcp</code></p> <p>Click Connect and confirm that everything works, as if we were communicating directly with the MCP server.</p> <p>Inspect the logs of the agentgateway console to see evidence that requests are indeed routed via the proxy.</p> <p>Terminate the agentgateway (press <code>Ctrl+C</code>).</p>"},{"location":"proxy-mcp/#configure-authentication","title":"Configure authentication","text":"<p>The project documentation provides an example for configuring MCP authentication directly on the proxy.</p> <p>Review the updated agentgateway configuration file:</p> ag-oauth-config.yaml<pre><code>binds:\n- port: 9000\n  listeners:\n  - routes:\n    - policies:\n        cors:\n          allowOrigins:\n          - \"*\"\n          allowHeaders:\n          - \"*\"\n        mcpAuthentication:\n          issuer: http://localhost:8080/realms/my-realm\n          jwks:\n            url: http://localhost:8080/realms/my-realm/protocol/openid-connect/certs\n          audiences:\n          - echo-mcp-server\n          resourceMetadata:\n            resource: http://localhost:9000/mcp\n            scopesSupported:\n            - openid\n            bearerMethodsSupported:\n            - header\n      backends:\n      - mcp:\n          targets:\n          - name: mcp\n            mcp:\n              host: http://localhost:8000/mcp\n</code></pre> <p>Above, note that the configuration utilizes the same <code>issuer</code>, <code>jwks.url</code>, and <code>audiences</code> field values for the authorization server.</p> <p>Copy the above <code>ag-oauth-config.yaml</code> script to your project:</p> <pre><code>cp ../artifacts/ag-oauth-config.yaml .\n</code></pre>"},{"location":"proxy-mcp/#test-it_1","title":"Test it","text":"<p>If it\u2019s not already running, start the basic, unprotected MCP server:</p> <pre><code>uv run main.py\n</code></pre> <p>Start the agentgateway:</p> <pre><code>./agentgateway -f ag-oauth-config.yaml\n</code></pre> <p>Finally, launch the MCP Inspector.</p> <pre><code>npx @modelcontextprotocol/inspector\n</code></pre> <p>This MCP server should be protected.</p> <p>Start by walking through the Guided OAuth flow:</p> <ul> <li>Click Open Auth Settings in the center of the page.</li> <li>Click Guided OAuth Flow.</li> <li>Like before, go through all steps from Metadata Discovery through to Token request.</li> <li>When instructed to follow the authorization URL, log in with the user credentials <code>eitan/test</code>.</li> <li>Copy and paste the authorization code into the corresponding field.</li> </ul> <p>When the authentication completes, we have been issued a token.</p> <p>Proceed to click Connect on the left hand panel, and to confirm that interaction with the MCP server continues to function as before: Tools -&gt; List Tools -&gt; Echo -&gt; Run Tool.</p>"},{"location":"proxy-mcp/#summary","title":"Summary","text":"<p>Congratulations!  You now have a flexible configuration: an MCP server fronted by an intelligent proxy where MCP authentication is configured.</p>"},{"location":"resource-server/","title":"Configure the resource server","text":"<p>The gist of the OAuth flow is that an authorization server issues tokens that give clients access to protected resources for a limited time.</p> <p>The resource server has the responsibility of enforcing the authorization policy, by:</p> <ul> <li>Checking that requests are accompanied by a JWT token.</li> <li>Verifying the token\u2019s authenticity (by checking the signature of the token).</li> <li>Verifying the token\u2019s expiration timestamp.</li> <li>Verifying the token\u2019s audience scope matches the intended audience (<code>echo-mcp-server</code>).</li> </ul> <p>In this section we begin implementing this enforcement by coding it directly in the application.</p>"},{"location":"resource-server/#instructions","title":"Instructions","text":"<p>Review the following updated application:</p> main-with-auth.py<pre><code>from typing import Annotated\n\nfrom fastmcp import FastMCP\nfrom fastmcp.server.auth import RemoteAuthProvider\nfrom fastmcp.server.auth.providers.jwt import JWTVerifier\nfrom pydantic import AnyHttpUrl, Field\n\nauth_provider = RemoteAuthProvider(\n    token_verifier=JWTVerifier(\n        jwks_uri=\"http://localhost:8080/realms/my-realm/protocol/openid-connect/certs\",\n        issuer=\"http://localhost:8080/realms/my-realm\",\n        audience=\"echo-mcp-server\"\n    ),\n    authorization_servers=[AnyHttpUrl(\"http://localhost:8080/realms/my-realm\")],\n    base_url=\"http://localhost:8000\"\n)\n\nmcp = FastMCP(\"MCP Echo Server\", auth=auth_provider)\n\n@mcp.tool\ndef echo(\n        message: Annotated[str, \"Message to echo\"],\n        repeat_count: Annotated[int, Field(description=\"Number of times to repeat the message\", ge=1, le=10)] = 3\n    ) -&gt; str:\n        \"\"\"Echo a message a specified number of times.\"\"\"\n        return message * repeat_count\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"http\", host=\"127.0.0.1\", port=8000)\n</code></pre> <p>The main difference from <code>main.py</code> is the construction of the FastMCP object with the auth provider <code>auth_provider</code>. Note how the <code>jwks_uri</code>, <code>issuer</code>, and <code>audience</code> match those of the authorization server provisioned in the previous section.</p> <p>Copy the above <code>main-with-auth.py</code> script to your project:</p> <pre><code>cp ../artifacts/main-with-auth.py .\n</code></pre>"},{"location":"resource-server/#test-it","title":"Test it","text":"<p>Start the MCP server:</p> <pre><code>uv run main-with-auth.py\n</code></pre> <p>In a separate terminal, attempt to make an HTTP POST request to the <code>/mcp</code> endpoint:</p> <pre><code>curl -s -v -X POST http://localhost:8000/mcp\n</code></pre> <p>Here are the salient parts of the captured response:</p> <pre><code>* Host localhost:8000 was resolved.\n* ...\n* Established connection to localhost (127.0.0.1 port 8000) from 127.0.0.1 port 65521\n* using HTTP/1.x\n&gt; POST /mcp HTTP/1.1\n&gt; Host: localhost:8000\n&gt; User-Agent: curl/8.16.0\n&gt; Accept: ..\n&gt;\n* Request completely sent off\n&lt; HTTP/1.1 401 Unauthorized\n&lt; date: Wed, 15 Oct 2025 18:09:13 GMT\n&lt; server: uvicorn\n&lt; content-type: application/json\n&lt; content-length: 74\n&lt; www-authenticate: Bearer error=\"invalid_token\", \\\n    error_description=\"Authentication required\", \\\n    resource_metadata=\"http://localhost:8000/.well-known/oauth-protected-resource\"\n&lt;\n* Connection #0 to host localhost:8000 left intact\n{\"error\": \"invalid_token\", \"error_description\": \"Authentication required\"}\n</code></pre> <p>Above, note that we were not granted access to the resource, due to the absence of a valid access token in the request.</p> <p>We get a 401 \u201cUnauthorized\u201d response. The interesting part is the presence of the response header <code>www-authenticate</code>, whose value include the <code>resource_metadata</code> attribute which tells the client where to find the authorization server.</p> <p>If we query that URL <sup>*</sup>:</p> <pre><code>curl -s http://localhost:8000/.well-known/oauth-protected-resource/mcp | jq\n</code></pre> <p><sup>*</sup> Above</p> <p>Per RFC 9728 the actual URL for the resource metadata is composed by appending the path of the requested resource: <code>/mcp</code>.</p> <p>We are indeed told where to find the authorization server:</p> <pre><code>{\n  \"resource\": \"http://localhost:8000/mcp\",\n  \"authorization_servers\": [\n    \"http://localhost:8080/realms/my-realm\"\n  ],\n  \"scopes_supported\": [],\n  \"bearer_methods_supported\": [\n    \"header\"\n  ]\n}\n</code></pre> <p>Above</p> <p>The field <code>scopes_supported</code> is empty because we didn\u2019t configure a list of valid scopes for the application.</p>"},{"location":"resource-server/#test-the-full-oauth-flow","title":"Test the full OAuth flow","text":"<p>Launch the MCP inspector:</p> <pre><code>npx @modelcontextprotocol/inspector\n</code></pre> <p>In the form panel on the left:</p> <ul> <li>Expand Authentication.</li> <li>Set the Client ID to <code>mcp-client</code>.</li> <li>Click Open Auth Settings (in the middle of the page).</li> </ul> <p>The Authentication Settings page in the inspector provides a guided OAuth flow.</p> <ol> <li>Metadata Discovery:  click the Continue button.   Expand the OAuth Metadata Sources.   The inspector fetched the discovery endpoint and used it to introspect Keycloak\u2019s metadata to discover the endpoints for registration, authorization, and the token endpoint.</li> <li>Client registration:  since we\u2019re using a registered client <code>mcp-client</code>, no registration takes place.  Click Continue</li> <li>Preparing Authorization: This is where the client constructs the authorization URL.    Follow the URL, and log in to Keycloak using the realm user <code>eitan</code> (password <code>test</code>).    An authorization code is presented.  Copy it and paste it into the Authorization Code field.    Click Continue</li> <li>Token Request: Click Continue.  The inspector will call the token endpoint with the supplied authorization code.</li> <li>Authentication Complete: Expand Access Tokens to revel the access token obtained from the token endpoint.    Feel free to use sites such as jwt.io to decode the access token and confirm that the audience scope is present in the token.</li> </ol> <p>The full flow functions:  Click Connect and confirm that you can still list tools and call the <code>echo</code> tool as before.</p> <p>Disconnect from the MCP Server and terminate the application.</p>"},{"location":"resource-server/#summary","title":"Summary","text":"<p>Congrats!  Basic OAuth authorization is functioning.</p> <p>But the solution is not ideal, in that the authorization enforcement concern is coupled to the application logic.</p> <p>A better solution would be to separate those two responsibilities, which can be implemented with the aid of a proxy \u2013 the subject of the next section.</p>"}]}